// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: colony.proto

package protocol

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/gogo/protobuf/gogoproto"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

type Object_Type int32

const (
	Object_WORKER Object_Type = 0
	Object_QUEEN  Object_Type = 1
	Object_FOOD   Object_Type = 2
	Object_STONE  Object_Type = 3
)

var Object_Type_name = map[int32]string{
	0: "WORKER",
	1: "QUEEN",
	2: "FOOD",
	3: "STONE",
}
var Object_Type_value = map[string]int32{
	"WORKER": 0,
	"QUEEN":  1,
	"FOOD":   2,
	"STONE":  3,
}

func (x Object_Type) String() string {
	return proto.EnumName(Object_Type_name, int32(x))
}
func (Object_Type) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_colony_14189129189997e3, []int{2, 0}
}

type Surface_Type int32

const (
	Surface_DIRT  Surface_Type = 0
	Surface_SOIL  Surface_Type = 1
	Surface_GRASS Surface_Type = 3
	Surface_WATER Surface_Type = 4
	Surface_ROCK  Surface_Type = 5
	Surface_HOLE  Surface_Type = 6
)

var Surface_Type_name = map[int32]string{
	0: "DIRT",
	1: "SOIL",
	3: "GRASS",
	4: "WATER",
	5: "ROCK",
	6: "HOLE",
}
var Surface_Type_value = map[string]int32{
	"DIRT":  0,
	"SOIL":  1,
	"GRASS": 3,
	"WATER": 4,
	"ROCK":  5,
	"HOLE":  6,
}

func (x Surface_Type) String() string {
	return proto.EnumName(Surface_Type_name, int32(x))
}
func (Surface_Type) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_colony_14189129189997e3, []int{3, 0}
}

type Error_Code int32

const (
	Error_UNDEFINED Error_Code = 0
)

var Error_Code_name = map[int32]string{
	0: "UNDEFINED",
}
var Error_Code_value = map[string]int32{
	"UNDEFINED": 0,
}

func (x Error_Code) String() string {
	return proto.EnumName(Error_Code_name, int32(x))
}
func (Error_Code) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_colony_14189129189997e3, []int{9, 0}
}

type World struct {
	// Next available id.
	NextId int32 `protobuf:"varint,1,opt,name=next_id,json=nextId,proto3" json:"next_id,omitempty"`
	// Colonies by id.
	Colonies map[int32]*Colony `protobuf:"bytes,2,rep,name=colonies,proto3" json:"colonies,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// Objects by location.
	Objects map[int32]*World_ObjectRow `protobuf:"bytes,3,rep,name=objects,proto3" json:"objects,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// Surfaces by location.
	Surfaces             map[int32]*World_SurfaceRow `protobuf:"bytes,4,rep,name=surfaces,proto3" json:"surfaces,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}                    `json:"-"`
	XXX_unrecognized     []byte                      `json:"-"`
	XXX_sizecache        int32                       `json:"-"`
}

func (m *World) Reset()         { *m = World{} }
func (m *World) String() string { return proto.CompactTextString(m) }
func (*World) ProtoMessage()    {}
func (*World) Descriptor() ([]byte, []int) {
	return fileDescriptor_colony_14189129189997e3, []int{0}
}
func (m *World) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *World) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_World.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *World) XXX_Merge(src proto.Message) {
	xxx_messageInfo_World.Merge(dst, src)
}
func (m *World) XXX_Size() int {
	return m.ProtoSize()
}
func (m *World) XXX_DiscardUnknown() {
	xxx_messageInfo_World.DiscardUnknown(m)
}

var xxx_messageInfo_World proto.InternalMessageInfo

type World_ObjectRow struct {
	Columns              map[int32]*Object `protobuf:"bytes,1,rep,name=columns,proto3" json:"columns,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *World_ObjectRow) Reset()         { *m = World_ObjectRow{} }
func (m *World_ObjectRow) String() string { return proto.CompactTextString(m) }
func (*World_ObjectRow) ProtoMessage()    {}
func (*World_ObjectRow) Descriptor() ([]byte, []int) {
	return fileDescriptor_colony_14189129189997e3, []int{0, 2}
}
func (m *World_ObjectRow) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *World_ObjectRow) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_World_ObjectRow.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *World_ObjectRow) XXX_Merge(src proto.Message) {
	xxx_messageInfo_World_ObjectRow.Merge(dst, src)
}
func (m *World_ObjectRow) XXX_Size() int {
	return m.ProtoSize()
}
func (m *World_ObjectRow) XXX_DiscardUnknown() {
	xxx_messageInfo_World_ObjectRow.DiscardUnknown(m)
}

var xxx_messageInfo_World_ObjectRow proto.InternalMessageInfo

type World_SurfaceRow struct {
	Columns              map[int32]*Surface `protobuf:"bytes,1,rep,name=columns,proto3" json:"columns,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *World_SurfaceRow) Reset()         { *m = World_SurfaceRow{} }
func (m *World_SurfaceRow) String() string { return proto.CompactTextString(m) }
func (*World_SurfaceRow) ProtoMessage()    {}
func (*World_SurfaceRow) Descriptor() ([]byte, []int) {
	return fileDescriptor_colony_14189129189997e3, []int{0, 4}
}
func (m *World_SurfaceRow) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *World_SurfaceRow) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_World_SurfaceRow.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *World_SurfaceRow) XXX_Merge(src proto.Message) {
	xxx_messageInfo_World_SurfaceRow.Merge(dst, src)
}
func (m *World_SurfaceRow) XXX_Size() int {
	return m.ProtoSize()
}
func (m *World_SurfaceRow) XXX_DiscardUnknown() {
	xxx_messageInfo_World_SurfaceRow.DiscardUnknown(m)
}

var xxx_messageInfo_World_SurfaceRow proto.InternalMessageInfo

type Colony struct {
	// Global Colony id.
	Id int32 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	// Name shown in UI.
	DisplayName string `protobuf:"bytes,2,opt,name=display_name,json=displayName,proto3" json:"display_name,omitempty"`
	// Phermones by location.
	Phermones map[int32]*Colony_PhermoneRow `protobuf:"bytes,3,rep,name=phermones,proto3" json:"phermones,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// Colony as a hole or a queen.
	//
	// Types that are valid to be assigned to State:
	//	*Colony_Hole
	//	*Colony_Queen
	State isColony_State `protobuf_oneof:"state"`
	// Location of Colony.
	X                    int32    `protobuf:"varint,6,opt,name=x,proto3" json:"x,omitempty"`
	Y                    int32    `protobuf:"varint,7,opt,name=y,proto3" json:"y,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Colony) Reset()         { *m = Colony{} }
func (m *Colony) String() string { return proto.CompactTextString(m) }
func (*Colony) ProtoMessage()    {}
func (*Colony) Descriptor() ([]byte, []int) {
	return fileDescriptor_colony_14189129189997e3, []int{1}
}
func (m *Colony) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Colony) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Colony.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Colony) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Colony.Merge(dst, src)
}
func (m *Colony) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Colony) XXX_DiscardUnknown() {
	xxx_messageInfo_Colony.DiscardUnknown(m)
}

var xxx_messageInfo_Colony proto.InternalMessageInfo

type isColony_State interface {
	isColony_State()
	MarshalTo([]byte) (int, error)
	ProtoSize() int
}

type Colony_Hole struct {
	Hole *Surface `protobuf:"bytes,4,opt,name=hole,proto3,oneof"`
}
type Colony_Queen struct {
	Queen *Object `protobuf:"bytes,5,opt,name=queen,proto3,oneof"`
}

func (*Colony_Hole) isColony_State()  {}
func (*Colony_Queen) isColony_State() {}

func (m *Colony) GetState() isColony_State {
	if m != nil {
		return m.State
	}
	return nil
}

func (m *Colony) GetHole() *Surface {
	if x, ok := m.GetState().(*Colony_Hole); ok {
		return x.Hole
	}
	return nil
}

func (m *Colony) GetQueen() *Object {
	if x, ok := m.GetState().(*Colony_Queen); ok {
		return x.Queen
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Colony) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _Colony_OneofMarshaler, _Colony_OneofUnmarshaler, _Colony_OneofSizer, []interface{}{
		(*Colony_Hole)(nil),
		(*Colony_Queen)(nil),
	}
}

func _Colony_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Colony)
	// state
	switch x := m.State.(type) {
	case *Colony_Hole:
		_ = b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Hole); err != nil {
			return err
		}
	case *Colony_Queen:
		_ = b.EncodeVarint(5<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Queen); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("Colony.State has unexpected type %T", x)
	}
	return nil
}

func _Colony_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Colony)
	switch tag {
	case 4: // state.hole
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Surface)
		err := b.DecodeMessage(msg)
		m.State = &Colony_Hole{msg}
		return true, err
	case 5: // state.queen
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Object)
		err := b.DecodeMessage(msg)
		m.State = &Colony_Queen{msg}
		return true, err
	default:
		return false, nil
	}
}

func _Colony_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*Colony)
	// state
	switch x := m.State.(type) {
	case *Colony_Hole:
		s := proto.Size(x.Hole)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Colony_Queen:
		s := proto.Size(x.Queen)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type Colony_PhermoneRow struct {
	Columns              map[int32]bool `protobuf:"bytes,1,rep,name=columns,proto3" json:"columns,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *Colony_PhermoneRow) Reset()         { *m = Colony_PhermoneRow{} }
func (m *Colony_PhermoneRow) String() string { return proto.CompactTextString(m) }
func (*Colony_PhermoneRow) ProtoMessage()    {}
func (*Colony_PhermoneRow) Descriptor() ([]byte, []int) {
	return fileDescriptor_colony_14189129189997e3, []int{1, 1}
}
func (m *Colony_PhermoneRow) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Colony_PhermoneRow) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Colony_PhermoneRow.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Colony_PhermoneRow) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Colony_PhermoneRow.Merge(dst, src)
}
func (m *Colony_PhermoneRow) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Colony_PhermoneRow) XXX_DiscardUnknown() {
	xxx_messageInfo_Colony_PhermoneRow.DiscardUnknown(m)
}

var xxx_messageInfo_Colony_PhermoneRow proto.InternalMessageInfo

type Object struct {
	// Global Object id.
	Id int32 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	// Object type.
	Type                 Object_Type `protobuf:"varint,2,opt,name=type,proto3,enum=Object_Type" json:"type,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *Object) Reset()         { *m = Object{} }
func (m *Object) String() string { return proto.CompactTextString(m) }
func (*Object) ProtoMessage()    {}
func (*Object) Descriptor() ([]byte, []int) {
	return fileDescriptor_colony_14189129189997e3, []int{2}
}
func (m *Object) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Object) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Object.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Object) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Object.Merge(dst, src)
}
func (m *Object) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Object) XXX_DiscardUnknown() {
	xxx_messageInfo_Object.DiscardUnknown(m)
}

var xxx_messageInfo_Object proto.InternalMessageInfo

type Surface struct {
	// Global Surface id.
	Id int32 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	// Surface type.
	Type                 Surface_Type `protobuf:"varint,2,opt,name=type,proto3,enum=Surface_Type" json:"type,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *Surface) Reset()         { *m = Surface{} }
func (m *Surface) String() string { return proto.CompactTextString(m) }
func (*Surface) ProtoMessage()    {}
func (*Surface) Descriptor() ([]byte, []int) {
	return fileDescriptor_colony_14189129189997e3, []int{3}
}
func (m *Surface) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Surface) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Surface.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Surface) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Surface.Merge(dst, src)
}
func (m *Surface) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Surface) XXX_DiscardUnknown() {
	xxx_messageInfo_Surface.DiscardUnknown(m)
}

var xxx_messageInfo_Surface proto.InternalMessageInfo

type ColonyReq struct {
	// Types that are valid to be assigned to Req:
	//	*ColonyReq_Subscribe
	//	*ColonyReq_Produce
	//	*ColonyReq_Poke
	Req                  isColonyReq_Req `protobuf_oneof:"req"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *ColonyReq) Reset()         { *m = ColonyReq{} }
func (m *ColonyReq) String() string { return proto.CompactTextString(m) }
func (*ColonyReq) ProtoMessage()    {}
func (*ColonyReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_colony_14189129189997e3, []int{4}
}
func (m *ColonyReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ColonyReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ColonyReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ColonyReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ColonyReq.Merge(dst, src)
}
func (m *ColonyReq) XXX_Size() int {
	return m.ProtoSize()
}
func (m *ColonyReq) XXX_DiscardUnknown() {
	xxx_messageInfo_ColonyReq.DiscardUnknown(m)
}

var xxx_messageInfo_ColonyReq proto.InternalMessageInfo

type isColonyReq_Req interface {
	isColonyReq_Req()
	MarshalTo([]byte) (int, error)
	ProtoSize() int
}

type ColonyReq_Subscribe struct {
	Subscribe *Subscribe `protobuf:"bytes,1,opt,name=subscribe,proto3,oneof"`
}
type ColonyReq_Produce struct {
	Produce *Produce `protobuf:"bytes,2,opt,name=produce,proto3,oneof"`
}
type ColonyReq_Poke struct {
	Poke *Poke `protobuf:"bytes,3,opt,name=poke,proto3,oneof"`
}

func (*ColonyReq_Subscribe) isColonyReq_Req() {}
func (*ColonyReq_Produce) isColonyReq_Req()   {}
func (*ColonyReq_Poke) isColonyReq_Req()      {}

func (m *ColonyReq) GetReq() isColonyReq_Req {
	if m != nil {
		return m.Req
	}
	return nil
}

func (m *ColonyReq) GetSubscribe() *Subscribe {
	if x, ok := m.GetReq().(*ColonyReq_Subscribe); ok {
		return x.Subscribe
	}
	return nil
}

func (m *ColonyReq) GetProduce() *Produce {
	if x, ok := m.GetReq().(*ColonyReq_Produce); ok {
		return x.Produce
	}
	return nil
}

func (m *ColonyReq) GetPoke() *Poke {
	if x, ok := m.GetReq().(*ColonyReq_Poke); ok {
		return x.Poke
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*ColonyReq) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _ColonyReq_OneofMarshaler, _ColonyReq_OneofUnmarshaler, _ColonyReq_OneofSizer, []interface{}{
		(*ColonyReq_Subscribe)(nil),
		(*ColonyReq_Produce)(nil),
		(*ColonyReq_Poke)(nil),
	}
}

func _ColonyReq_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*ColonyReq)
	// req
	switch x := m.Req.(type) {
	case *ColonyReq_Subscribe:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Subscribe); err != nil {
			return err
		}
	case *ColonyReq_Produce:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Produce); err != nil {
			return err
		}
	case *ColonyReq_Poke:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Poke); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("ColonyReq.Req has unexpected type %T", x)
	}
	return nil
}

func _ColonyReq_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*ColonyReq)
	switch tag {
	case 1: // req.subscribe
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Subscribe)
		err := b.DecodeMessage(msg)
		m.Req = &ColonyReq_Subscribe{msg}
		return true, err
	case 2: // req.produce
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Produce)
		err := b.DecodeMessage(msg)
		m.Req = &ColonyReq_Produce{msg}
		return true, err
	case 3: // req.poke
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Poke)
		err := b.DecodeMessage(msg)
		m.Req = &ColonyReq_Poke{msg}
		return true, err
	default:
		return false, nil
	}
}

func _ColonyReq_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*ColonyReq)
	// req
	switch x := m.Req.(type) {
	case *ColonyReq_Subscribe:
		s := proto.Size(x.Subscribe)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ColonyReq_Produce:
		s := proto.Size(x.Produce)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ColonyReq_Poke:
		s := proto.Size(x.Poke)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type Subscribe struct {
	// Global Colony id.
	Id                   int32    `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Subscribe) Reset()         { *m = Subscribe{} }
func (m *Subscribe) String() string { return proto.CompactTextString(m) }
func (*Subscribe) ProtoMessage()    {}
func (*Subscribe) Descriptor() ([]byte, []int) {
	return fileDescriptor_colony_14189129189997e3, []int{5}
}
func (m *Subscribe) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Subscribe) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Subscribe.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Subscribe) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Subscribe.Merge(dst, src)
}
func (m *Subscribe) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Subscribe) XXX_DiscardUnknown() {
	xxx_messageInfo_Subscribe.DiscardUnknown(m)
}

var xxx_messageInfo_Subscribe proto.InternalMessageInfo

type Produce struct {
	// Maximum number of ant to produce.
	MaxProduction_       int32    `protobuf:"varint,1,opt,name=max_production_,json=maxProduction,proto3" json:"max_production_,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Produce) Reset()         { *m = Produce{} }
func (m *Produce) String() string { return proto.CompactTextString(m) }
func (*Produce) ProtoMessage()    {}
func (*Produce) Descriptor() ([]byte, []int) {
	return fileDescriptor_colony_14189129189997e3, []int{6}
}
func (m *Produce) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Produce) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Produce.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Produce) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Produce.Merge(dst, src)
}
func (m *Produce) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Produce) XXX_DiscardUnknown() {
	xxx_messageInfo_Produce.DiscardUnknown(m)
}

var xxx_messageInfo_Produce proto.InternalMessageInfo

type Poke struct {
	// Poke whatever is at a location.
	X                    int32    `protobuf:"varint,1,opt,name=x,proto3" json:"x,omitempty"`
	Y                    int32    `protobuf:"varint,2,opt,name=y,proto3" json:"y,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Poke) Reset()         { *m = Poke{} }
func (m *Poke) String() string { return proto.CompactTextString(m) }
func (*Poke) ProtoMessage()    {}
func (*Poke) Descriptor() ([]byte, []int) {
	return fileDescriptor_colony_14189129189997e3, []int{7}
}
func (m *Poke) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Poke) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Poke.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Poke) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Poke.Merge(dst, src)
}
func (m *Poke) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Poke) XXX_DiscardUnknown() {
	xxx_messageInfo_Poke.DiscardUnknown(m)
}

var xxx_messageInfo_Poke proto.InternalMessageInfo

type ColonyResp struct {
	// Types that are valid to be assigned to Req:
	//	*ColonyResp_Error
	//	*ColonyResp_View
	//	*ColonyResp_Update
	Req isColonyResp_Req `protobuf_oneof:"req"`
	// Debug messages
	Messages             []string `protobuf:"bytes,4,rep,name=messages,proto3" json:"messages,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ColonyResp) Reset()         { *m = ColonyResp{} }
func (m *ColonyResp) String() string { return proto.CompactTextString(m) }
func (*ColonyResp) ProtoMessage()    {}
func (*ColonyResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_colony_14189129189997e3, []int{8}
}
func (m *ColonyResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ColonyResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ColonyResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ColonyResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ColonyResp.Merge(dst, src)
}
func (m *ColonyResp) XXX_Size() int {
	return m.ProtoSize()
}
func (m *ColonyResp) XXX_DiscardUnknown() {
	xxx_messageInfo_ColonyResp.DiscardUnknown(m)
}

var xxx_messageInfo_ColonyResp proto.InternalMessageInfo

type isColonyResp_Req interface {
	isColonyResp_Req()
	MarshalTo([]byte) (int, error)
	ProtoSize() int
}

type ColonyResp_Error struct {
	Error *Error `protobuf:"bytes,1,opt,name=error,proto3,oneof"`
}
type ColonyResp_View struct {
	View *View `protobuf:"bytes,2,opt,name=view,proto3,oneof"`
}
type ColonyResp_Update struct {
	Update *ViewUpdate `protobuf:"bytes,3,opt,name=update,proto3,oneof"`
}

func (*ColonyResp_Error) isColonyResp_Req()  {}
func (*ColonyResp_View) isColonyResp_Req()   {}
func (*ColonyResp_Update) isColonyResp_Req() {}

func (m *ColonyResp) GetReq() isColonyResp_Req {
	if m != nil {
		return m.Req
	}
	return nil
}

func (m *ColonyResp) GetError() *Error {
	if x, ok := m.GetReq().(*ColonyResp_Error); ok {
		return x.Error
	}
	return nil
}

func (m *ColonyResp) GetView() *View {
	if x, ok := m.GetReq().(*ColonyResp_View); ok {
		return x.View
	}
	return nil
}

func (m *ColonyResp) GetUpdate() *ViewUpdate {
	if x, ok := m.GetReq().(*ColonyResp_Update); ok {
		return x.Update
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*ColonyResp) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _ColonyResp_OneofMarshaler, _ColonyResp_OneofUnmarshaler, _ColonyResp_OneofSizer, []interface{}{
		(*ColonyResp_Error)(nil),
		(*ColonyResp_View)(nil),
		(*ColonyResp_Update)(nil),
	}
}

func _ColonyResp_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*ColonyResp)
	// req
	switch x := m.Req.(type) {
	case *ColonyResp_Error:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Error); err != nil {
			return err
		}
	case *ColonyResp_View:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.View); err != nil {
			return err
		}
	case *ColonyResp_Update:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Update); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("ColonyResp.Req has unexpected type %T", x)
	}
	return nil
}

func _ColonyResp_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*ColonyResp)
	switch tag {
	case 1: // req.error
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Error)
		err := b.DecodeMessage(msg)
		m.Req = &ColonyResp_Error{msg}
		return true, err
	case 2: // req.view
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(View)
		err := b.DecodeMessage(msg)
		m.Req = &ColonyResp_View{msg}
		return true, err
	case 3: // req.update
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ViewUpdate)
		err := b.DecodeMessage(msg)
		m.Req = &ColonyResp_Update{msg}
		return true, err
	default:
		return false, nil
	}
}

func _ColonyResp_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*ColonyResp)
	// req
	switch x := m.Req.(type) {
	case *ColonyResp_Error:
		s := proto.Size(x.Error)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ColonyResp_View:
		s := proto.Size(x.View)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ColonyResp_Update:
		s := proto.Size(x.Update)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type Error struct {
	// Error code.
	Code Error_Code `protobuf:"varint,1,opt,name=code,proto3,enum=Error_Code" json:"code,omitempty"`
	// Human readible error message.
	Msg                  string   `protobuf:"bytes,2,opt,name=msg,proto3" json:"msg,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Error) Reset()         { *m = Error{} }
func (m *Error) String() string { return proto.CompactTextString(m) }
func (*Error) ProtoMessage()    {}
func (*Error) Descriptor() ([]byte, []int) {
	return fileDescriptor_colony_14189129189997e3, []int{9}
}
func (m *Error) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Error) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Error.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Error) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Error.Merge(dst, src)
}
func (m *Error) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Error) XXX_DiscardUnknown() {
	xxx_messageInfo_Error.DiscardUnknown(m)
}

var xxx_messageInfo_Error proto.InternalMessageInfo

type View struct {
	// View of a World.
	World *World `protobuf:"bytes,1,opt,name=world,proto3" json:"world,omitempty"`
	// Dimensions of View.
	XMin                 int32    `protobuf:"varint,2,opt,name=x_min,json=xMin,proto3" json:"x_min,omitempty"`
	XMax                 int32    `protobuf:"varint,3,opt,name=x_max,json=xMax,proto3" json:"x_max,omitempty"`
	YMin                 int32    `protobuf:"varint,4,opt,name=y_min,json=yMin,proto3" json:"y_min,omitempty"`
	YMax                 int32    `protobuf:"varint,5,opt,name=y_max,json=yMax,proto3" json:"y_max,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *View) Reset()         { *m = View{} }
func (m *View) String() string { return proto.CompactTextString(m) }
func (*View) ProtoMessage()    {}
func (*View) Descriptor() ([]byte, []int) {
	return fileDescriptor_colony_14189129189997e3, []int{10}
}
func (m *View) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *View) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_View.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *View) XXX_Merge(src proto.Message) {
	xxx_messageInfo_View.Merge(dst, src)
}
func (m *View) XXX_Size() int {
	return m.ProtoSize()
}
func (m *View) XXX_DiscardUnknown() {
	xxx_messageInfo_View.DiscardUnknown(m)
}

var xxx_messageInfo_View proto.InternalMessageInfo

type ViewUpdate struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ViewUpdate) Reset()         { *m = ViewUpdate{} }
func (m *ViewUpdate) String() string { return proto.CompactTextString(m) }
func (*ViewUpdate) ProtoMessage()    {}
func (*ViewUpdate) Descriptor() ([]byte, []int) {
	return fileDescriptor_colony_14189129189997e3, []int{11}
}
func (m *ViewUpdate) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ViewUpdate) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ViewUpdate.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ViewUpdate) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ViewUpdate.Merge(dst, src)
}
func (m *ViewUpdate) XXX_Size() int {
	return m.ProtoSize()
}
func (m *ViewUpdate) XXX_DiscardUnknown() {
	xxx_messageInfo_ViewUpdate.DiscardUnknown(m)
}

var xxx_messageInfo_ViewUpdate proto.InternalMessageInfo

func init() {
	proto.RegisterType((*World)(nil), "World")
	proto.RegisterMapType((map[int32]*Colony)(nil), "World.ColoniesEntry")
	proto.RegisterMapType((map[int32]*World_ObjectRow)(nil), "World.ObjectsEntry")
	proto.RegisterMapType((map[int32]*World_SurfaceRow)(nil), "World.SurfacesEntry")
	proto.RegisterType((*World_ObjectRow)(nil), "World.ObjectRow")
	proto.RegisterMapType((map[int32]*Object)(nil), "World.ObjectRow.ColumnsEntry")
	proto.RegisterType((*World_SurfaceRow)(nil), "World.SurfaceRow")
	proto.RegisterMapType((map[int32]*Surface)(nil), "World.SurfaceRow.ColumnsEntry")
	proto.RegisterType((*Colony)(nil), "Colony")
	proto.RegisterMapType((map[int32]*Colony_PhermoneRow)(nil), "Colony.PhermonesEntry")
	proto.RegisterType((*Colony_PhermoneRow)(nil), "Colony.PhermoneRow")
	proto.RegisterMapType((map[int32]bool)(nil), "Colony.PhermoneRow.ColumnsEntry")
	proto.RegisterType((*Object)(nil), "Object")
	proto.RegisterType((*Surface)(nil), "Surface")
	proto.RegisterType((*ColonyReq)(nil), "ColonyReq")
	proto.RegisterType((*Subscribe)(nil), "Subscribe")
	proto.RegisterType((*Produce)(nil), "Produce")
	proto.RegisterType((*Poke)(nil), "Poke")
	proto.RegisterType((*ColonyResp)(nil), "ColonyResp")
	proto.RegisterType((*Error)(nil), "Error")
	proto.RegisterType((*View)(nil), "View")
	proto.RegisterType((*ViewUpdate)(nil), "ViewUpdate")
	proto.RegisterEnum("Object_Type", Object_Type_name, Object_Type_value)
	proto.RegisterEnum("Surface_Type", Surface_Type_name, Surface_Type_value)
	proto.RegisterEnum("Error_Code", Error_Code_name, Error_Code_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// ColonyServiceClient is the client API for ColonyService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type ColonyServiceClient interface {
	Colony(ctx context.Context, opts ...grpc.CallOption) (ColonyService_ColonyClient, error)
}

type colonyServiceClient struct {
	cc *grpc.ClientConn
}

func NewColonyServiceClient(cc *grpc.ClientConn) ColonyServiceClient {
	return &colonyServiceClient{cc}
}

func (c *colonyServiceClient) Colony(ctx context.Context, opts ...grpc.CallOption) (ColonyService_ColonyClient, error) {
	stream, err := c.cc.NewStream(ctx, &_ColonyService_serviceDesc.Streams[0], "/ColonyService/Colony", opts...)
	if err != nil {
		return nil, err
	}
	x := &colonyServiceColonyClient{stream}
	return x, nil
}

type ColonyService_ColonyClient interface {
	Send(*ColonyReq) error
	Recv() (*ColonyResp, error)
	grpc.ClientStream
}

type colonyServiceColonyClient struct {
	grpc.ClientStream
}

func (x *colonyServiceColonyClient) Send(m *ColonyReq) error {
	return x.ClientStream.SendMsg(m)
}

func (x *colonyServiceColonyClient) Recv() (*ColonyResp, error) {
	m := new(ColonyResp)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// ColonyServiceServer is the server API for ColonyService service.
type ColonyServiceServer interface {
	Colony(ColonyService_ColonyServer) error
}

func RegisterColonyServiceServer(s *grpc.Server, srv ColonyServiceServer) {
	s.RegisterService(&_ColonyService_serviceDesc, srv)
}

func _ColonyService_Colony_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(ColonyServiceServer).Colony(&colonyServiceColonyServer{stream})
}

type ColonyService_ColonyServer interface {
	Send(*ColonyResp) error
	Recv() (*ColonyReq, error)
	grpc.ServerStream
}

type colonyServiceColonyServer struct {
	grpc.ServerStream
}

func (x *colonyServiceColonyServer) Send(m *ColonyResp) error {
	return x.ServerStream.SendMsg(m)
}

func (x *colonyServiceColonyServer) Recv() (*ColonyReq, error) {
	m := new(ColonyReq)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _ColonyService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "ColonyService",
	HandlerType: (*ColonyServiceServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Colony",
			Handler:       _ColonyService_Colony_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "colony.proto",
}

func (m *World) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *World) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.NextId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintColony(dAtA, i, uint64(m.NextId))
	}
	if len(m.Colonies) > 0 {
		for k, _ := range m.Colonies {
			dAtA[i] = 0x12
			i++
			v := m.Colonies[k]
			msgSize := 0
			if v != nil {
				msgSize = v.ProtoSize()
				msgSize += 1 + sovColony(uint64(msgSize))
			}
			mapSize := 1 + sovColony(uint64(k)) + msgSize
			i = encodeVarintColony(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintColony(dAtA, i, uint64(k))
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintColony(dAtA, i, uint64(v.ProtoSize()))
				n1, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n1
			}
		}
	}
	if len(m.Objects) > 0 {
		for k, _ := range m.Objects {
			dAtA[i] = 0x1a
			i++
			v := m.Objects[k]
			msgSize := 0
			if v != nil {
				msgSize = v.ProtoSize()
				msgSize += 1 + sovColony(uint64(msgSize))
			}
			mapSize := 1 + sovColony(uint64(k)) + msgSize
			i = encodeVarintColony(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintColony(dAtA, i, uint64(k))
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintColony(dAtA, i, uint64(v.ProtoSize()))
				n2, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n2
			}
		}
	}
	if len(m.Surfaces) > 0 {
		for k, _ := range m.Surfaces {
			dAtA[i] = 0x22
			i++
			v := m.Surfaces[k]
			msgSize := 0
			if v != nil {
				msgSize = v.ProtoSize()
				msgSize += 1 + sovColony(uint64(msgSize))
			}
			mapSize := 1 + sovColony(uint64(k)) + msgSize
			i = encodeVarintColony(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintColony(dAtA, i, uint64(k))
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintColony(dAtA, i, uint64(v.ProtoSize()))
				n3, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n3
			}
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *World_ObjectRow) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *World_ObjectRow) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Columns) > 0 {
		for k, _ := range m.Columns {
			dAtA[i] = 0xa
			i++
			v := m.Columns[k]
			msgSize := 0
			if v != nil {
				msgSize = v.ProtoSize()
				msgSize += 1 + sovColony(uint64(msgSize))
			}
			mapSize := 1 + sovColony(uint64(k)) + msgSize
			i = encodeVarintColony(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintColony(dAtA, i, uint64(k))
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintColony(dAtA, i, uint64(v.ProtoSize()))
				n4, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n4
			}
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *World_SurfaceRow) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *World_SurfaceRow) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Columns) > 0 {
		for k, _ := range m.Columns {
			dAtA[i] = 0xa
			i++
			v := m.Columns[k]
			msgSize := 0
			if v != nil {
				msgSize = v.ProtoSize()
				msgSize += 1 + sovColony(uint64(msgSize))
			}
			mapSize := 1 + sovColony(uint64(k)) + msgSize
			i = encodeVarintColony(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintColony(dAtA, i, uint64(k))
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintColony(dAtA, i, uint64(v.ProtoSize()))
				n5, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n5
			}
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Colony) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Colony) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintColony(dAtA, i, uint64(m.Id))
	}
	if len(m.DisplayName) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintColony(dAtA, i, uint64(len(m.DisplayName)))
		i += copy(dAtA[i:], m.DisplayName)
	}
	if len(m.Phermones) > 0 {
		for k, _ := range m.Phermones {
			dAtA[i] = 0x1a
			i++
			v := m.Phermones[k]
			msgSize := 0
			if v != nil {
				msgSize = v.ProtoSize()
				msgSize += 1 + sovColony(uint64(msgSize))
			}
			mapSize := 1 + sovColony(uint64(k)) + msgSize
			i = encodeVarintColony(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintColony(dAtA, i, uint64(k))
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintColony(dAtA, i, uint64(v.ProtoSize()))
				n6, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n6
			}
		}
	}
	if m.State != nil {
		nn7, err := m.State.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn7
	}
	if m.X != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintColony(dAtA, i, uint64(m.X))
	}
	if m.Y != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintColony(dAtA, i, uint64(m.Y))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Colony_Hole) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Hole != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintColony(dAtA, i, uint64(m.Hole.ProtoSize()))
		n8, err := m.Hole.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	return i, nil
}
func (m *Colony_Queen) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Queen != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintColony(dAtA, i, uint64(m.Queen.ProtoSize()))
		n9, err := m.Queen.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	return i, nil
}
func (m *Colony_PhermoneRow) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Colony_PhermoneRow) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Columns) > 0 {
		for k, _ := range m.Columns {
			dAtA[i] = 0xa
			i++
			v := m.Columns[k]
			mapSize := 1 + sovColony(uint64(k)) + 1 + 1
			i = encodeVarintColony(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintColony(dAtA, i, uint64(k))
			dAtA[i] = 0x10
			i++
			if v {
				dAtA[i] = 1
			} else {
				dAtA[i] = 0
			}
			i++
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Object) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Object) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintColony(dAtA, i, uint64(m.Id))
	}
	if m.Type != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintColony(dAtA, i, uint64(m.Type))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Surface) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Surface) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintColony(dAtA, i, uint64(m.Id))
	}
	if m.Type != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintColony(dAtA, i, uint64(m.Type))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ColonyReq) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ColonyReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Req != nil {
		nn10, err := m.Req.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn10
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ColonyReq_Subscribe) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Subscribe != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintColony(dAtA, i, uint64(m.Subscribe.ProtoSize()))
		n11, err := m.Subscribe.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	return i, nil
}
func (m *ColonyReq_Produce) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Produce != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintColony(dAtA, i, uint64(m.Produce.ProtoSize()))
		n12, err := m.Produce.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	return i, nil
}
func (m *ColonyReq_Poke) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Poke != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintColony(dAtA, i, uint64(m.Poke.ProtoSize()))
		n13, err := m.Poke.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n13
	}
	return i, nil
}
func (m *Subscribe) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Subscribe) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintColony(dAtA, i, uint64(m.Id))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Produce) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Produce) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.MaxProduction_ != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintColony(dAtA, i, uint64(m.MaxProduction_))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Poke) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Poke) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.X != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintColony(dAtA, i, uint64(m.X))
	}
	if m.Y != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintColony(dAtA, i, uint64(m.Y))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ColonyResp) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ColonyResp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Req != nil {
		nn14, err := m.Req.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn14
	}
	if len(m.Messages) > 0 {
		for _, s := range m.Messages {
			dAtA[i] = 0x22
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ColonyResp_Error) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Error != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintColony(dAtA, i, uint64(m.Error.ProtoSize()))
		n15, err := m.Error.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n15
	}
	return i, nil
}
func (m *ColonyResp_View) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.View != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintColony(dAtA, i, uint64(m.View.ProtoSize()))
		n16, err := m.View.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n16
	}
	return i, nil
}
func (m *ColonyResp_Update) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Update != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintColony(dAtA, i, uint64(m.Update.ProtoSize()))
		n17, err := m.Update.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n17
	}
	return i, nil
}
func (m *Error) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Error) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Code != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintColony(dAtA, i, uint64(m.Code))
	}
	if len(m.Msg) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintColony(dAtA, i, uint64(len(m.Msg)))
		i += copy(dAtA[i:], m.Msg)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *View) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *View) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.World != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintColony(dAtA, i, uint64(m.World.ProtoSize()))
		n18, err := m.World.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n18
	}
	if m.XMin != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintColony(dAtA, i, uint64(m.XMin))
	}
	if m.XMax != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintColony(dAtA, i, uint64(m.XMax))
	}
	if m.YMin != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintColony(dAtA, i, uint64(m.YMin))
	}
	if m.YMax != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintColony(dAtA, i, uint64(m.YMax))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ViewUpdate) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ViewUpdate) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func encodeVarintColony(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *World) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NextId != 0 {
		n += 1 + sovColony(uint64(m.NextId))
	}
	if len(m.Colonies) > 0 {
		for k, v := range m.Colonies {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.ProtoSize()
				l += 1 + sovColony(uint64(l))
			}
			mapEntrySize := 1 + sovColony(uint64(k)) + l
			n += mapEntrySize + 1 + sovColony(uint64(mapEntrySize))
		}
	}
	if len(m.Objects) > 0 {
		for k, v := range m.Objects {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.ProtoSize()
				l += 1 + sovColony(uint64(l))
			}
			mapEntrySize := 1 + sovColony(uint64(k)) + l
			n += mapEntrySize + 1 + sovColony(uint64(mapEntrySize))
		}
	}
	if len(m.Surfaces) > 0 {
		for k, v := range m.Surfaces {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.ProtoSize()
				l += 1 + sovColony(uint64(l))
			}
			mapEntrySize := 1 + sovColony(uint64(k)) + l
			n += mapEntrySize + 1 + sovColony(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *World_ObjectRow) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Columns) > 0 {
		for k, v := range m.Columns {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.ProtoSize()
				l += 1 + sovColony(uint64(l))
			}
			mapEntrySize := 1 + sovColony(uint64(k)) + l
			n += mapEntrySize + 1 + sovColony(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *World_SurfaceRow) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Columns) > 0 {
		for k, v := range m.Columns {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.ProtoSize()
				l += 1 + sovColony(uint64(l))
			}
			mapEntrySize := 1 + sovColony(uint64(k)) + l
			n += mapEntrySize + 1 + sovColony(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Colony) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovColony(uint64(m.Id))
	}
	l = len(m.DisplayName)
	if l > 0 {
		n += 1 + l + sovColony(uint64(l))
	}
	if len(m.Phermones) > 0 {
		for k, v := range m.Phermones {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.ProtoSize()
				l += 1 + sovColony(uint64(l))
			}
			mapEntrySize := 1 + sovColony(uint64(k)) + l
			n += mapEntrySize + 1 + sovColony(uint64(mapEntrySize))
		}
	}
	if m.State != nil {
		n += m.State.ProtoSize()
	}
	if m.X != 0 {
		n += 1 + sovColony(uint64(m.X))
	}
	if m.Y != 0 {
		n += 1 + sovColony(uint64(m.Y))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Colony_Hole) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Hole != nil {
		l = m.Hole.ProtoSize()
		n += 1 + l + sovColony(uint64(l))
	}
	return n
}
func (m *Colony_Queen) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Queen != nil {
		l = m.Queen.ProtoSize()
		n += 1 + l + sovColony(uint64(l))
	}
	return n
}
func (m *Colony_PhermoneRow) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Columns) > 0 {
		for k, v := range m.Columns {
			_ = k
			_ = v
			mapEntrySize := 1 + sovColony(uint64(k)) + 1 + 1
			n += mapEntrySize + 1 + sovColony(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Object) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovColony(uint64(m.Id))
	}
	if m.Type != 0 {
		n += 1 + sovColony(uint64(m.Type))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Surface) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovColony(uint64(m.Id))
	}
	if m.Type != 0 {
		n += 1 + sovColony(uint64(m.Type))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ColonyReq) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Req != nil {
		n += m.Req.ProtoSize()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ColonyReq_Subscribe) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Subscribe != nil {
		l = m.Subscribe.ProtoSize()
		n += 1 + l + sovColony(uint64(l))
	}
	return n
}
func (m *ColonyReq_Produce) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Produce != nil {
		l = m.Produce.ProtoSize()
		n += 1 + l + sovColony(uint64(l))
	}
	return n
}
func (m *ColonyReq_Poke) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Poke != nil {
		l = m.Poke.ProtoSize()
		n += 1 + l + sovColony(uint64(l))
	}
	return n
}
func (m *Subscribe) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovColony(uint64(m.Id))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Produce) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MaxProduction_ != 0 {
		n += 1 + sovColony(uint64(m.MaxProduction_))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Poke) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.X != 0 {
		n += 1 + sovColony(uint64(m.X))
	}
	if m.Y != 0 {
		n += 1 + sovColony(uint64(m.Y))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ColonyResp) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Req != nil {
		n += m.Req.ProtoSize()
	}
	if len(m.Messages) > 0 {
		for _, s := range m.Messages {
			l = len(s)
			n += 1 + l + sovColony(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ColonyResp_Error) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Error != nil {
		l = m.Error.ProtoSize()
		n += 1 + l + sovColony(uint64(l))
	}
	return n
}
func (m *ColonyResp_View) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.View != nil {
		l = m.View.ProtoSize()
		n += 1 + l + sovColony(uint64(l))
	}
	return n
}
func (m *ColonyResp_Update) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Update != nil {
		l = m.Update.ProtoSize()
		n += 1 + l + sovColony(uint64(l))
	}
	return n
}
func (m *Error) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovColony(uint64(m.Code))
	}
	l = len(m.Msg)
	if l > 0 {
		n += 1 + l + sovColony(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *View) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.World != nil {
		l = m.World.ProtoSize()
		n += 1 + l + sovColony(uint64(l))
	}
	if m.XMin != 0 {
		n += 1 + sovColony(uint64(m.XMin))
	}
	if m.XMax != 0 {
		n += 1 + sovColony(uint64(m.XMax))
	}
	if m.YMin != 0 {
		n += 1 + sovColony(uint64(m.YMin))
	}
	if m.YMax != 0 {
		n += 1 + sovColony(uint64(m.YMax))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ViewUpdate) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovColony(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozColony(x uint64) (n int) {
	return sovColony(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *World) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowColony
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: World: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: World: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextId", wireType)
			}
			m.NextId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowColony
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NextId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Colonies", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowColony
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthColony
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Colonies == nil {
				m.Colonies = make(map[int32]*Colony)
			}
			var mapkey int32
			var mapvalue *Colony
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowColony
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowColony
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowColony
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthColony
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthColony
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &Colony{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipColony(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthColony
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Colonies[mapkey] = mapvalue
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Objects", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowColony
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthColony
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Objects == nil {
				m.Objects = make(map[int32]*World_ObjectRow)
			}
			var mapkey int32
			var mapvalue *World_ObjectRow
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowColony
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowColony
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowColony
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthColony
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthColony
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &World_ObjectRow{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipColony(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthColony
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Objects[mapkey] = mapvalue
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Surfaces", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowColony
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthColony
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Surfaces == nil {
				m.Surfaces = make(map[int32]*World_SurfaceRow)
			}
			var mapkey int32
			var mapvalue *World_SurfaceRow
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowColony
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowColony
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowColony
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthColony
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthColony
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &World_SurfaceRow{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipColony(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthColony
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Surfaces[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipColony(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthColony
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *World_ObjectRow) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowColony
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ObjectRow: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ObjectRow: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Columns", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowColony
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthColony
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Columns == nil {
				m.Columns = make(map[int32]*Object)
			}
			var mapkey int32
			var mapvalue *Object
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowColony
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowColony
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowColony
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthColony
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthColony
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &Object{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipColony(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthColony
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Columns[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipColony(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthColony
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *World_SurfaceRow) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowColony
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SurfaceRow: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SurfaceRow: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Columns", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowColony
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthColony
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Columns == nil {
				m.Columns = make(map[int32]*Surface)
			}
			var mapkey int32
			var mapvalue *Surface
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowColony
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowColony
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowColony
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthColony
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthColony
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &Surface{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipColony(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthColony
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Columns[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipColony(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthColony
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Colony) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowColony
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Colony: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Colony: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowColony
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisplayName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowColony
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthColony
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DisplayName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Phermones", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowColony
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthColony
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Phermones == nil {
				m.Phermones = make(map[int32]*Colony_PhermoneRow)
			}
			var mapkey int32
			var mapvalue *Colony_PhermoneRow
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowColony
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowColony
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowColony
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthColony
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthColony
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &Colony_PhermoneRow{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipColony(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthColony
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Phermones[mapkey] = mapvalue
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hole", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowColony
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthColony
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Surface{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.State = &Colony_Hole{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Queen", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowColony
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthColony
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Object{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.State = &Colony_Queen{v}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field X", wireType)
			}
			m.X = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowColony
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.X |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Y", wireType)
			}
			m.Y = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowColony
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Y |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipColony(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthColony
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Colony_PhermoneRow) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowColony
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PhermoneRow: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PhermoneRow: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Columns", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowColony
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthColony
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Columns == nil {
				m.Columns = make(map[int32]bool)
			}
			var mapkey int32
			var mapvalue bool
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowColony
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowColony
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapvaluetemp int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowColony
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvaluetemp |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					mapvalue = bool(mapvaluetemp != 0)
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipColony(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthColony
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Columns[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipColony(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthColony
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Object) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowColony
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Object: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Object: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowColony
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowColony
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (Object_Type(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipColony(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthColony
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Surface) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowColony
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Surface: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Surface: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowColony
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowColony
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (Surface_Type(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipColony(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthColony
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ColonyReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowColony
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ColonyReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ColonyReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Subscribe", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowColony
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthColony
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Subscribe{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Req = &ColonyReq_Subscribe{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Produce", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowColony
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthColony
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Produce{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Req = &ColonyReq_Produce{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Poke", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowColony
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthColony
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Poke{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Req = &ColonyReq_Poke{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipColony(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthColony
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Subscribe) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowColony
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Subscribe: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Subscribe: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowColony
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipColony(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthColony
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Produce) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowColony
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Produce: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Produce: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxProduction_", wireType)
			}
			m.MaxProduction_ = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowColony
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxProduction_ |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipColony(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthColony
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Poke) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowColony
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Poke: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Poke: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field X", wireType)
			}
			m.X = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowColony
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.X |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Y", wireType)
			}
			m.Y = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowColony
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Y |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipColony(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthColony
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ColonyResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowColony
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ColonyResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ColonyResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowColony
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthColony
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Error{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Req = &ColonyResp_Error{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field View", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowColony
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthColony
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &View{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Req = &ColonyResp_View{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Update", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowColony
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthColony
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ViewUpdate{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Req = &ColonyResp_Update{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Messages", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowColony
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthColony
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Messages = append(m.Messages, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipColony(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthColony
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Error) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowColony
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Error: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Error: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowColony
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= (Error_Code(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowColony
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthColony
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipColony(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthColony
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *View) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowColony
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: View: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: View: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field World", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowColony
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthColony
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.World == nil {
				m.World = &World{}
			}
			if err := m.World.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field XMin", wireType)
			}
			m.XMin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowColony
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.XMin |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field XMax", wireType)
			}
			m.XMax = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowColony
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.XMax |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field YMin", wireType)
			}
			m.YMin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowColony
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.YMin |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field YMax", wireType)
			}
			m.YMax = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowColony
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.YMax |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipColony(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthColony
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ViewUpdate) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowColony
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ViewUpdate: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ViewUpdate: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipColony(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthColony
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipColony(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowColony
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowColony
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowColony
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthColony
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowColony
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipColony(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthColony = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowColony   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("colony.proto", fileDescriptor_colony_14189129189997e3) }

var fileDescriptor_colony_14189129189997e3 = []byte{
	// 992 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x8c, 0x56, 0x5f, 0x73, 0xdb, 0x44,
	0x10, 0xd7, 0xd9, 0x92, 0xff, 0xac, 0x9d, 0x20, 0x2e, 0x05, 0x34, 0x2e, 0x75, 0x83, 0x06, 0x4a,
	0x60, 0xa6, 0x6a, 0x31, 0x0c, 0x74, 0xf2, 0xd6, 0xc4, 0x2a, 0xce, 0x34, 0xd8, 0xc9, 0x39, 0x21,
	0x33, 0xbc, 0x64, 0x64, 0xf9, 0x9a, 0x88, 0x58, 0x3a, 0x47, 0x92, 0x13, 0xe9, 0x11, 0x66, 0x78,
	0x60, 0x86, 0x37, 0xbe, 0x00, 0x9f, 0xa1, 0x9f, 0xa2, 0x8f, 0x7c, 0x04, 0x08, 0x5f, 0x84, 0xb9,
	0xd3, 0xc9, 0xb6, 0xdc, 0x74, 0xda, 0xb7, 0xdb, 0xdf, 0xee, 0xed, 0xfe, 0x7e, 0xbb, 0xab, 0xb3,
	0xa1, 0xe9, 0xb2, 0x09, 0x0b, 0x52, 0x6b, 0x1a, 0xb2, 0x98, 0xb5, 0x1e, 0x9e, 0x79, 0xf1, 0xf9,
	0x6c, 0x64, 0xb9, 0xcc, 0x7f, 0x74, 0xc6, 0xce, 0xd8, 0x23, 0x01, 0x8f, 0x66, 0x2f, 0x84, 0x25,
	0x0c, 0x71, 0xca, 0xc2, 0xcd, 0x97, 0x1a, 0x68, 0x27, 0x2c, 0x9c, 0x8c, 0xf1, 0x47, 0x50, 0x0d,
	0x68, 0x12, 0x9f, 0x7a, 0x63, 0x03, 0x6d, 0xa2, 0x2d, 0x8d, 0x54, 0xb8, 0xb9, 0x37, 0xc6, 0x8f,
	0xa1, 0x26, 0x2a, 0x78, 0x34, 0x32, 0x4a, 0x9b, 0xe5, 0xad, 0x46, 0xe7, 0x8e, 0x25, 0xae, 0x58,
	0xbb, 0x12, 0xb6, 0x83, 0x38, 0x4c, 0xc9, 0x3c, 0x0a, 0x3f, 0x84, 0x2a, 0x1b, 0xfd, 0x4c, 0xdd,
	0x38, 0x32, 0xca, 0xe2, 0xc2, 0x86, 0xbc, 0x30, 0xc8, 0xd0, 0x2c, 0x3e, 0x8f, 0xe1, 0x05, 0xa2,
	0x59, 0xf8, 0xc2, 0x71, 0x69, 0x64, 0xa8, 0x85, 0x02, 0x43, 0x09, 0xcb, 0x02, 0x79, 0x54, 0xab,
	0x0b, 0x6b, 0x85, 0xda, 0x58, 0x87, 0xf2, 0x05, 0x4d, 0x25, 0x71, 0x7e, 0xc4, 0xf7, 0x40, 0xbb,
	0x72, 0x26, 0x33, 0x6a, 0x94, 0x36, 0xd1, 0x56, 0xa3, 0x53, 0xcd, 0xc8, 0xa6, 0x24, 0x43, 0xb7,
	0x4b, 0x4f, 0x50, 0x6b, 0x1f, 0x9a, 0xcb, 0x84, 0x6e, 0x49, 0xf2, 0xa0, 0x98, 0x44, 0x2f, 0xc8,
	0x20, 0xec, 0x7a, 0x39, 0xdb, 0xef, 0x08, 0xea, 0x73, 0x07, 0xfe, 0x0e, 0xaa, 0x2e, 0x9b, 0xcc,
	0xfc, 0x20, 0x32, 0x90, 0x90, 0x74, 0x6f, 0xf5, 0x2e, 0x27, 0xc4, 0xfd, 0xb2, 0x19, 0x32, 0xba,
	0xb5, 0x0b, 0xcd, 0x65, 0xc7, 0xbb, 0x28, 0x93, 0x29, 0x97, 0xb8, 0xf4, 0x61, 0xad, 0xd0, 0xba,
	0x5b, 0xb2, 0x7c, 0x5e, 0xcc, 0xf2, 0x7e, 0xb1, 0xe3, 0x2b, 0xda, 0xfe, 0x40, 0x00, 0x0b, 0x0f,
	0x7e, 0xb2, 0x2a, 0xae, 0xfd, 0xda, 0xed, 0x37, 0xa8, 0xeb, 0xbe, 0x55, 0x5d, 0xbb, 0xc8, 0xab,
	0x36, 0xcf, 0xb9, 0xa0, 0x63, 0xbe, 0x2c, 0x43, 0x25, 0x1b, 0x27, 0x5e, 0x87, 0xd2, 0x7c, 0x61,
	0x4b, 0xde, 0x18, 0x7f, 0x02, 0xcd, 0xb1, 0x17, 0x4d, 0x27, 0x4e, 0x7a, 0x1a, 0x38, 0x7e, 0x96,
	0xa5, 0x4e, 0x1a, 0x12, 0xeb, 0x3b, 0x3e, 0xc5, 0xdf, 0x40, 0x7d, 0x7a, 0x4e, 0x43, 0x9f, 0x05,
	0x34, 0xdf, 0xcf, 0x0f, 0xe5, 0x76, 0x58, 0x07, 0xb9, 0x23, 0xe3, 0xbd, 0x08, 0xc4, 0x6d, 0x50,
	0xcf, 0xd9, 0x84, 0x1a, 0x6a, 0x91, 0x56, 0x4f, 0x21, 0x02, 0xc7, 0xf7, 0x41, 0xbb, 0x9c, 0x51,
	0x1a, 0x18, 0x5a, 0x61, 0x2a, 0x3d, 0x85, 0x64, 0x38, 0x6e, 0x02, 0x4a, 0x8c, 0x8a, 0x20, 0x8a,
	0x12, 0x6e, 0xa5, 0x46, 0x35, 0xb3, 0xd2, 0xd6, 0x21, 0xac, 0x17, 0x2b, 0xdf, 0xd2, 0x98, 0x2f,
	0x8a, 0x8d, 0xd9, 0x58, 0xa5, 0xbc, 0x32, 0xb2, 0xdf, 0x10, 0x34, 0x96, 0x5c, 0x78, 0x7b, 0x75,
	0x66, 0x9b, 0xb7, 0x24, 0x78, 0xc3, 0xd4, 0xb6, 0xdf, 0x3a, 0xb5, 0x3b, 0xcb, 0xe4, 0x6a, 0x4b,
	0x3c, 0x76, 0xaa, 0xa0, 0x45, 0xb1, 0x13, 0x53, 0x33, 0x80, 0x4a, 0xd6, 0x92, 0xd7, 0x66, 0xb6,
	0x09, 0x6a, 0x9c, 0x4e, 0xb3, 0xbb, 0xeb, 0x9d, 0xa6, 0xec, 0x9c, 0x75, 0x94, 0x4e, 0x29, 0x11,
	0x1e, 0xb3, 0x03, 0x2a, 0xb7, 0x30, 0x40, 0xe5, 0x64, 0x40, 0x9e, 0xdb, 0x44, 0x57, 0x70, 0x1d,
	0xb4, 0xc3, 0x63, 0xdb, 0xee, 0xeb, 0x08, 0xd7, 0x40, 0x7d, 0x36, 0x18, 0x74, 0xf5, 0x12, 0x07,
	0x87, 0x47, 0x83, 0xbe, 0xad, 0x97, 0xcd, 0x5f, 0x11, 0x54, 0xe5, 0x90, 0x6e, 0xd9, 0x92, 0xe5,
	0x8a, 0x6b, 0xf9, 0x30, 0x97, 0x4b, 0x76, 0x65, 0xc9, 0x1a, 0xa8, 0xdd, 0x3d, 0x72, 0xa4, 0x2b,
	0xfc, 0x34, 0x1c, 0xec, 0xed, 0xeb, 0x88, 0x57, 0xf9, 0x9e, 0x3c, 0x1d, 0x0e, 0xf5, 0x32, 0x3f,
	0x9e, 0x3c, 0x3d, 0xb2, 0x89, 0xae, 0x72, 0x3f, 0x19, 0xec, 0x3e, 0xd7, 0x35, 0x7e, 0xea, 0x0d,
	0xf6, 0x6d, 0xbd, 0x62, 0xfe, 0x82, 0xa0, 0x2e, 0x1f, 0x1e, 0x7a, 0x89, 0xbf, 0x84, 0x7a, 0x34,
	0x1b, 0x45, 0x6e, 0xe8, 0x8d, 0xa8, 0x60, 0xd3, 0xe8, 0x80, 0x35, 0xcc, 0x91, 0x9e, 0x42, 0x16,
	0x6e, 0xfc, 0x29, 0x54, 0xa7, 0x21, 0x1b, 0xcf, 0xdc, 0xc5, 0x97, 0x70, 0x90, 0xd9, 0x3d, 0x85,
	0xe4, 0x2e, 0x7c, 0x17, 0xd4, 0x29, 0xbb, 0xa0, 0x46, 0x59, 0x84, 0x68, 0xd6, 0x01, 0xbb, 0x10,
	0x2b, 0xc9, 0xc1, 0x1d, 0x0d, 0xca, 0x21, 0xbd, 0x34, 0xef, 0x42, 0x7d, 0x5e, 0x63, 0xb5, 0x13,
	0xe6, 0x57, 0x50, 0x95, 0x69, 0xf1, 0x03, 0x78, 0xcf, 0x77, 0x92, 0xd3, 0x2c, 0x75, 0xec, 0xb1,
	0xe0, 0x54, 0xc6, 0xad, 0xf9, 0x4e, 0x72, 0x30, 0x47, 0x4d, 0x13, 0x54, 0x5e, 0x26, 0x5b, 0x68,
	0x54, 0x58, 0xe8, 0x92, 0x5c, 0x68, 0xf3, 0x4f, 0x04, 0x90, 0xeb, 0x8e, 0xa6, 0xfc, 0xa3, 0xa6,
	0x61, 0xc8, 0x42, 0x29, 0xba, 0x62, 0xd9, 0xdc, 0xe2, 0xdf, 0x86, 0x80, 0xb9, 0x8c, 0x2b, 0x8f,
	0x5e, 0x4b, 0xa5, 0x9a, 0xf5, 0xa3, 0x47, 0xaf, 0xb9, 0x0c, 0x0e, 0xe2, 0xcf, 0xa0, 0x32, 0x9b,
	0x8e, 0x9d, 0x38, 0x57, 0xd9, 0x10, 0xee, 0x63, 0x01, 0xf5, 0x14, 0x22, 0x9d, 0xb8, 0x05, 0x35,
	0x9f, 0x46, 0x91, 0x73, 0x26, 0x7f, 0x45, 0xea, 0x64, 0x6e, 0xe7, 0x9d, 0x38, 0x04, 0x4d, 0x14,
	0xc6, 0xf7, 0x41, 0x75, 0xd9, 0x38, 0x9b, 0xc1, 0x7a, 0xa7, 0x91, 0xd1, 0xb1, 0x76, 0xd9, 0x98,
	0x12, 0xe1, 0xe0, 0x1b, 0xee, 0x47, 0x67, 0xf2, 0xf5, 0xe0, 0x47, 0xf3, 0x03, 0x50, 0xb9, 0x1f,
	0xaf, 0x41, 0xfd, 0xb8, 0xdf, 0xb5, 0x9f, 0xed, 0xf5, 0xed, 0xae, 0xae, 0x98, 0x09, 0xa8, 0x9c,
	0x0d, 0xfe, 0x18, 0xb4, 0x6b, 0xfe, 0x04, 0xce, 0x15, 0x8a, 0x07, 0x91, 0x64, 0x20, 0xde, 0x00,
	0x2d, 0x39, 0xf5, 0xbd, 0x40, 0x36, 0x48, 0x4d, 0x7e, 0xf0, 0x02, 0x09, 0x3a, 0x89, 0x90, 0x25,
	0x40, 0x27, 0xe1, 0x60, 0x2a, 0x22, 0xd5, 0x0c, 0x4c, 0x65, 0x64, 0x2a, 0x22, 0xb5, 0x1c, 0x74,
	0x12, 0xb3, 0x09, 0xb0, 0xe8, 0x43, 0xe7, 0x5b, 0xf9, 0x8b, 0x98, 0x0e, 0x69, 0x78, 0xe5, 0xb9,
	0x94, 0x77, 0x4d, 0x3e, 0x91, 0x60, 0xcd, 0x37, 0xb0, 0xd5, 0xb0, 0x16, 0x53, 0xd9, 0x42, 0x8f,
	0xd1, 0x4e, 0xfb, 0xd5, 0xbf, 0x6d, 0xe5, 0xd5, 0x4d, 0x1b, 0xfd, 0x7d, 0xd3, 0x46, 0xff, 0xdc,
	0xb4, 0x95, 0xbf, 0xfe, 0x6b, 0xa3, 0x9f, 0x6a, 0xe2, 0xcf, 0x81, 0xcb, 0x26, 0xa3, 0x8a, 0x38,
	0x7d, 0xfd, 0x7f, 0x00, 0x00, 0x00, 0xff, 0xff, 0xb1, 0xef, 0x43, 0x77, 0x65, 0x08, 0x00, 0x00,
}
